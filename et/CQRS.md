# CQRS pattern

CQRS는 데이터 스토리지에 읽고, 업데이트하는 연산을 분리한다. 당신의 어플리케이션안의 CQRS의 실행은 이것의 퍼포멘스와 유연선 확장성을 최대화 시킬 수 있다. CQRS로 마이그레이션하여 생성된 유연성은 시스템을 시간이 지남에 따라 더 잘 발전시킬 수 있게 하며 업데이트 명령이 도메인 수준에서 병합 충돌을 일으키는 것을 방지합니다.

## Context and problem

기존 아키텍처에서는 동일한 데이터 모델을 사용하여 데이터베이스를 쿼리하고 업데이트합니다. 이는 간단하며 기본 CRUD 작업에 적합합니다. 그러나 더 복잡한 응용 프로그램에서는 이 접근 방식이 다루기 어려워질 수 있습니다. 예를 들어, 읽기 측면에서 응용 프로그램은 여러 가지 쿼리를 수행하여 서로 다른 모양을 가진 데이터 전송 개체(DTO)를 반환할 수 있습니다. 오브젝트 매핑이 복잡해질 수 있습니다. 쓰기 측면에서, 모델은 복잡한 검증과 비즈니스 논리를 구현할 수 있다. 결과적으로 지나치게 복잡한 모형이 될 수 있습니다.

읽기 및 쓰기 워크로드는 성능 및 확장 요구사항이 매우 다른 비대칭 워크로드인 경우가 많습니다.

![A traditional CRUD architecture](https://docs.microsoft.com/en-us/azure/architecture/patterns/_images/command-and-query-responsibility-segregation-cqrs-tradition-crud.png)

- 데이터의 읽기 표현과 쓰기 표현 사이에 종종 불일치가 있습니다. 예를 들어 추가 열이나 속성이 작업의 일부로 필요하지 않더라도 올바르게 업데이트되어야 합니다.
- 데이터 경합은 동일한 데이터 세트에서 작업이 병렬로 수행될 때 발생할 수 있다.
- 기존의 접근 방식은 데이터 저장소 및 데이터 액세스 계층에 대한 부하와 정보를 검색하는 데 필요한 쿼리의 복잡성으로 인해 성능에 부정적인 영향을 미칠 수 있습니다.
- 각 엔터티는 읽기 및 쓰기 작업을 모두 수행하므로 보안 및 사용 권한 관리가 복잡해질 수 있으며, 이로 인해 잘못된 컨텍스트에서 데이터가 노출될 수 있습니다.

## Solution

CQRS는 데이터를 업데이트하는 명령을 사용하여 읽기 및 쓰기를 서로 다른 모델로 구분하고, 데이터를 읽기 위한 쿼리를 사용합니다.

- 명령은 데이터 중심이 아니라 작업 기반이어야 합니다("예약 상태를 예약됨"으로 설정하지 않음).
- 명령은 동기식으로 처리되지 않고 비동기 처리를 위해 큐에 배치될 수 있다.
- 쿼리는 데이터베이스를 수정하지 않습니다. 쿼리는 도메인 지식을 캡슐화하지 않는 DTO를 반환합니다.

그런 다음 다음 다이어그램에 표시된 것처럼 모델을 분리할 수 있습니다. 단, 절대적인 요구 사항은 아닙니다.

![A basic CQRS architecture](https://docs.microsoft.com/en-us/azure/architecture/patterns/_images/command-and-query-responsibility-segregation-cqrs-basic.png)

별도의 쿼리 및 업데이트 모델을 사용하면 설계 및 구현이 간소화됩니다. 그러나 한 가지 단점은 O/RM 도구와 같은 발판이 되는 메커니즘을 사용하는 데이터베이스 스키마에서 CQRS 코드를 자동으로 생성할 수 없다는 것이다.

보다 강력한 분리를 위해 읽기 데이터와 쓰기 데이터를 물리적으로 분리할 수 있습니다. 이 경우 읽기 데이터베이스는 쿼리에 최적화된 자체 데이터 스키마를 사용할 수 있습니다. 예를 들어, 복잡한 조인이나 복잡한 O/RM 매핑을 피하기 위해 데이터의 구체화된 뷰를 저장할 수 있습니다. 다른 유형의 데이터 저장소를 사용할 수도 있습니다. 예를 들어, 읽기 데이터베이스가 문서 데이터베이스인 반면 쓰기 데이터베이스는 관계형 데이터베이스일 수 있습니다.

별도의 읽기 및 쓰기 데이터베이스를 사용하는 경우, 데이터베이스를 동기화해야 합니다. 일반적으로 데이터베이스를 업데이트할 때마다 쓰기 모델이 이벤트를 게시하도록 하면 됩니다. 이벤트 사용에 대한 자세한 내용은 이벤트 기반 아키텍처 스타일을 참조하십시오. 데이터베이스를 업데이트하고 이벤트를 게시하는 작업은 단일 트랜잭션에서 수행되어야 합니다.

![A CQRS architecture with separate read and write stores](https://docs.microsoft.com/en-us/azure/architecture/patterns/_images/command-and-query-responsibility-segregation-cqrs-separate-stores.png)

읽기 저장소는 쓰기 저장소의 읽기 전용 복제본이거나 읽기 저장소와 쓰기 저장소의 구조가 서로 다를 수 있습니다. 읽기 전용 복제본을 여러 개 사용하면 특히 읽기 전용 복제본이 응용프로그램 인스턴스 근처에 있는 분산 시나리오에서 쿼리 성능을 향상시킬 수 있습니다.

읽기 저장소와 쓰기 저장소가 분리되어 있어 각 저장소의 크기가 부하에 맞게 적절히 조정될 수도 있습니다. 예를 들어, 읽기 저장소는 일반적으로 쓰기 저장소의 부하보다 훨씬 더 높습니다.

CQRS의 일부 구현에서는 이벤트 소싱 패턴을 사용합니다. 이 패턴을 사용하면 애플리케이션 상태가 이벤트 시퀀스로 저장됩니다. 각 이벤트는 데이터에 대한 변경사항 집합을 나타냅니다. 현재 상태는 이벤트를 재생하여 구성됩니다. CQRS 컨텍스트에서 이벤트 소싱의 한 가지 이점은 동일한 이벤트를 사용하여 다른 구성 요소, 특히 읽기 모델을 알릴 수 있다는 것입니다. 읽기 모델은 이벤트를 사용하여 현재 상태의 스냅샷을 생성하므로 쿼리에 더 효율적입니다. 그러나 이벤트 소싱은 설계에 복잡성을 더합니다.

CQRS의 이점:

- **Independent scaling**. CQRS를 사용하면 읽기 및 쓰기 워크로드를 독립적으로 확장할 수 있으며, 결과적으로 잠금 경합이 줄어들 수 있습니다.
- **Optimized data schemas**. 읽기 쪽에서는 쿼리에 최적화된 스키마를 사용할 수 있고 쓰기 쪽에서는 업데이트에 최적화된 스키마를 사용할 수 있습니다.
- **Security**. 올바른 도메인 엔티티만 데이터에 대해 쓰기를 수행하는지 확인하는 것이 더 쉽습니다.
- **Separation of concerns**. 읽기 측과 쓰기 측을 분리하면 모델이 보다 유지 관리가 용이하고 유연해질 수 있습니다. 대부분의 복잡한 비즈니스 논리는 쓰기 모델에 들어간다. 읽기 모델은 비교적 단순할 수 있습니다.
- **Simpler queries**. 읽기 데이터베이스에 구체화된 보기를 저장함으로써, 응용프로그램은 쿼리할 때 복잡한 조인을 피할 수 있습니다.



## Implementation issues and considerations

이 패턴을 구현하는데 있는 몇가지의 과제 :

- **Complexity**. CQRS의 기본 아이디어는 간단하다. 그러나 특히 이벤트 소싱 패턴을 포함하는 경우 응용프로그램 설계가 더 복잡해질 수 있습니다.
- **Messaging**. CQRS에는 메시징이 필요하지 않지만, 일반적으로 메시징을 사용하여 명령을 처리하고 업데이트 이벤트를 게시합니다. 이 경우 응용 프로그램에서 메시지 오류 또는 중복 메시지를 처리해야 합니다. 우선 순위가 다른 명령을 처리하는 방법은 우선 순위 대기열의 지침을 참조하십시오.
- **Eventual consistency**. 읽기 및 쓰기 데이터베이스를 분리할 경우 읽기 데이터가 오래되었을 수 있습니다. 읽기 모델 저장소는 쓰기 모델 저장소의 변경 사항을 반영하도록 업데이트되어야 하며, 사용자가 오래된 읽기 데이터를 기반으로 요청을 실행한 경우를 감지하기 어려울 수 있습니다.



## When to use CQRS pattern

하단의 시나리오일때 CQRS을 고려:

- 많은 사용자가 동일한 데이터에 병렬로 액세스하는 협업 도메인. CQRS를 사용하면 도메인 수준에서 병합 충돌을 최소화할 수 있을 정도로 세분화된 명령을 정의할 수 있으며, 실제로 발생하는 충돌은 명령으로 병합할 수 있습니다.
- 사용자가 일련의 단계 또는 복잡한 도메인 모델로 복잡한 프로세스를 안내하는 작업 기반 사용자 인터페이스입니다. 쓰기 모델에는 비즈니스 로직, 입력 유효성 검사 및 비즈니스 유효성 검사가 포함된 완전한 명령 처리 스택이 있습니다. 쓰기 모델은 데이터 변경을 위한 단일 단위(DDD 용어에서 집합체)로 관련 객체 집합을 취급하고 이러한 객체가 항상 일관된 상태에 있도록 보장할 수 있다. 읽기 모델은 비즈니스 로직이나 유효성 검사 스택이 없으며 보기 모델에서 사용할 수 있도록 DTO만 반환합니다. 읽기 모델은 결국 쓰기 모델과 일치한다.
- 특히 읽기 수가 쓰기 수보다 훨씬 많은 경우 데이터 읽기 성능을 데이터 쓰기 성능과 별도로 미세 조정해야 하는 시나리오입니다. 이 시나리오에서는 읽기 모델을 축소할 수 있지만 몇 가지 인스턴스에 대해서만 쓰기 모델을 실행할 수 있습니다. 적은 수의 쓰기 모델 인스턴스도 병합 충돌 발생을 최소화하는 데 도움이 됩니다.
- 개발자 한 팀이 쓰기 모델의 일부인 복잡한 도메인 모델에 집중하고 다른 팀은 읽기 모델과 사용자 인터페이스에 집중할 수 있는 시나리오입니다.
- 시간이 지남에 따라 시스템이 진화할 것으로 예상되며 여러 버전의 모델을 포함할 수 있거나 비즈니스 규칙이 정기적으로 변경되는 시나리오입니다.
- 다른 시스템과의 통합, 특히 이벤트 소싱과 함께, 한 서브시스템의 일시적인 장애가 다른 서브시스템의 가용성에 영향을 미치지 않아야 한다.

이러한 패턴은 이때 추천되지 않느낟.

- 도메인 또는 비즈니스 규칙은 간단하다.
- 간단한 CRUD 스타일의 사용자 인터페이스와 데이터 액세스 작업만으로도 충분하다.



## Event Sourcing and CQRS pattern

CQRS 패턴은 이벤트 소싱 패턴과 함께 자주 사용됩니다. CQRS 기반 시스템은 별도의 읽기 및 쓰기 데이터 모델을 사용하며, 각 모델은 관련 작업에 맞게 조정되며 종종 물리적으로 별도의 저장소에 위치합니다. 이벤트 소싱 패턴과 함께 사용할 경우 이벤트의 저장소는 쓰기 모델이며 공식적인 정보 소스입니다. CQRS 기반 시스템의 읽기 모델은 데이터의 구체화된 보기(일반적으로 고도로 비규격화된 보기)를 제공한다. 이러한 보기는 응용프로그램의 인터페이스 및 표시 요구사항에 맞게 조정되므로 표시 및 쿼리 성능을 극대화할 수 있습니다.

특정 시점에 실제 데이터가 아닌 이벤트 스트림을 쓰기 저장소로 사용하면 단일 Aggregate에서 업데이트 충돌을 방지하고 성능과 확장성을 극대화할 수 있습니다. 이벤트는 읽기 저장소를 채우는 데 사용되는 데이터의 구체화된 뷰를 비동기적으로 생성하는 데 사용될 수 있습니다.

이벤트 저장소는 공식적인 정보 소스이기 때문에 시스템이 진화하거나 읽기 모델을 변경해야 할 때 구체화된 뷰를 삭제하고 과거 이벤트를 모두 재생하여 현재 상태를 새로 나타낼 수 있습니다. 구체화된 뷰는 사실상 데이터의 내구성 있는 읽기 전용 캐시입니다.

CQRS를 이벤트 소싱 패턴과 함께 사용할 경우 다음을 고려해야한다:

- 쓰기 저장소와 읽기 저장소가 분리되어 있는 모든 시스템과 마찬가지로, 이 패턴을 기반으로 하는 시스템은 결국 일관성이 있을 뿐이다. 생성되는 이벤트와 업데이트되는 데이터 저장소 사이에 약간의 지연이 발생합니다.
- 이 패턴은 이벤트를 시작하고 처리하기 위해 코드가 생성되어야 하며 쿼리나 읽기 모델에 필요한 적절한 뷰나 객체를 어셈블하거나 업데이트해야 하기 때문에 복잡성을 더한다. 이벤트 소싱 패턴과 함께 사용될 때 CQRS 패턴의 복잡성은 성공적인 구현을 더 어렵게 만들 수 있으며, 시스템 설계에 대한 다른 접근 방식이 필요하다. 그러나 이벤트 소싱을 사용하면 도메인을 쉽게 모델링할 수 있으며, 데이터의 변경 내용이 유지되므로 보기를 재구성하거나 새 도메인을 쉽게 만들 수 있습니다.
- 특정 엔티티 또는 엔티티 컬렉션에 대한 이벤트를 재생하고 처리하여 데이터의 읽기 모델 또는 투영에 사용할 구체화된 뷰를 생성하려면 상당한 처리 시간과 리소스 사용이 필요할 수 있습니다. 모든 관련 사건을 조사해야 할 수 있기 때문에 장기간에 걸쳐 값의 합계 또는 분석이 필요한 경우 특히 그렇다. 발생한 특정 작업 수 또는 엔티티의 현재 상태와 같은 예약된 간격으로 데이터의 스냅샷을 구현하여 이 문제를 해결합니다.

출처 : https://docs.microsoft.com/en-us/azure/architecture/patterns/cqrs