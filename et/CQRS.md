# CQRS

CQRS는 데이터 스토리지에 읽고, 업데이트하는 연산을 분리한다. 당신의 어플리케이션안의 CQRS의 실행은 이것의 퍼포멘스와 유연선 확장성을 최대화 시킬 수 있다. CQRS로 마이그레이션하여 생성된 유연성은 시스템을 시간이 지남에 따라 더 잘 발전시킬 수 있게 하며 업데이트 명령이 도메인 수준에서 병합 충돌을 일으키는 것을 방지합니다.

## Context and problem

기존 아키텍처에서는 동일한 데이터 모델을 사용하여 데이터베이스를 쿼리하고 업데이트합니다. 이는 간단하며 기본 CRUD 작업에 적합합니다. 그러나 더 복잡한 응용 프로그램에서는 이 접근 방식이 다루기 어려워질 수 있습니다. 예를 들어, 읽기 측면에서 응용 프로그램은 여러 가지 쿼리를 수행하여 서로 다른 모양을 가진 데이터 전송 개체(DTO)를 반환할 수 있습니다. 오브젝트 매핑이 복잡해질 수 있습니다. 쓰기 측면에서, 모델은 복잡한 검증과 비즈니스 논리를 구현할 수 있다. 결과적으로 지나치게 복잡한 모형이 될 수 있습니다.

읽기 및 쓰기 워크로드는 성능 및 확장 요구사항이 매우 다른 비대칭 워크로드인 경우가 많습니다.

![A traditional CRUD architecture](https://docs.microsoft.com/en-us/azure/architecture/patterns/_images/command-and-query-responsibility-segregation-cqrs-tradition-crud.png)

- 데이터의 읽기 표현과 쓰기 표현 사이에 종종 불일치가 있습니다. 예를 들어 추가 열이나 속성이 작업의 일부로 필요하지 않더라도 올바르게 업데이트되어야 합니다.
- 데이터 경합은 동일한 데이터 세트에서 작업이 병렬로 수행될 때 발생할 수 있다.
- 기존의 접근 방식은 데이터 저장소 및 데이터 액세스 계층에 대한 부하와 정보를 검색하는 데 필요한 쿼리의 복잡성으로 인해 성능에 부정적인 영향을 미칠 수 있습니다.
- 각 엔터티는 읽기 및 쓰기 작업을 모두 수행하므로 보안 및 사용 권한 관리가 복잡해질 수 있으며, 이로 인해 잘못된 컨텍스트에서 데이터가 노출될 수 있습니다.

## Solution

CQRS는 데이터를 업데이트하는 명령을 사용하여 읽기 및 쓰기를 서로 다른 모델로 구분하고, 데이터를 읽기 위한 쿼리를 사용합니다.

- 명령은 데이터 중심이 아니라 작업 기반이어야 합니다("예약 상태를 예약됨"으로 설정하지 않음).
- 명령은 동기식으로 처리되지 않고 비동기 처리를 위해 큐에 배치될 수 있다.
- 쿼리는 데이터베이스를 수정하지 않습니다. 쿼리는 도메인 지식을 캡슐화하지 않는 DTO를 반환합니다.

그런 다음 다음 다이어그램에 표시된 것처럼 모델을 분리할 수 있습니다. 단, 절대적인 요구 사항은 아닙니다.

![A basic CQRS architecture](https://docs.microsoft.com/en-us/azure/architecture/patterns/_images/command-and-query-responsibility-segregation-cqrs-basic.png)

별도의 쿼리 및 업데이트 모델을 사용하면 설계 및 구현이 간소화됩니다. 그러나 한 가지 단점은 O/RM 도구와 같은 발판이 되는 메커니즘을 사용하는 데이터베이스 스키마에서 CQRS 코드를 자동으로 생성할 수 없다는 것이다.

보다 강력한 분리를 위해 읽기 데이터와 쓰기 데이터를 물리적으로 분리할 수 있습니다. 이 경우 읽기 데이터베이스는 쿼리에 최적화된 자체 데이터 스키마를 사용할 수 있습니다. 예를 들어, 복잡한 조인이나 복잡한 O/RM 매핑을 피하기 위해 데이터의 구체화된 뷰를 저장할 수 있습니다. 다른 유형의 데이터 저장소를 사용할 수도 있습니다. 예를 들어, 읽기 데이터베이스가 문서 데이터베이스인 반면 쓰기 데이터베이스는 관계형 데이터베이스일 수 있습니다.챙



출처 : https://docs.microsoft.com/en-us/azure/architecture/patterns/cqrs