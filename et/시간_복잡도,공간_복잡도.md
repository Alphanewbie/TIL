# 시간 복잡도, 공간 복잡도

## 시간 복잡도

### 정의

> 시간 복잡도란 컴퓨터가 알고리즘을 실행하는데 걸리는 시간의 양을 계산하는 복잡도

시간 복잡도란 컴퓨터가 알고리즘을 실행하는데 사용하는 연산의 수를 세어서 측정한다.



좀 더 정확하게 따지자면

- 시간 복잡도 = 알고리즘을 구성하는 명령어가 실행되는 횟수 + 명령어 실행 시간



### 예시

예를 들면 삽입 정렬을 예시로 들기 위해 간단하게 선택 정렬을 설명하면

![선택정렬](https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif)

삽입 정렬의 경우에는 이미 정렬이 되어 있는 배열의 경우에는 검사만 한번 하면 되기 때문에 반복문이 한번만 돌아가면 된다.

하지만, 반대로 역순으로 정렬되어 있는 경우에는 현재 위치에서 역순으로 되돌아가면서 한칸씩 밀어주는 작업이 필요하기 때문에 모든 n의 위치마다 n -1만큼 추가로 연산을 해줘야 한다.



### 계산

즉, 시간은 대략적으로 예상할 수 있기 때문에 예측을 한다.

- Best-case : 가장 최상의 경우를 생각하는 경우  -> 안 쓰는 방법, 간단하게 정렬로 생각해보면 어떤 수열이 정렬되서 들어올 가능성은 없기 때문
  - Big-Omega 표기법
- Worst-case : 가장 최악의 경우를 생각하는 경우 -> 아무리 시간이 오래걸려도 이 시간 안에는 결과가 나온다는 의미
  - Big-O 표기법 -> 주로 쓰이는 방법


## 시간복잡도가 중요한 이유

같은 문제를 풀더라도 전혀 다른 시간 복잡도를 통해 문제를 풀 수 있기 때문



### 버블 정렬

가장 간단하지만 가장 오래걸리는 정렬 방법.

방법도 가장 간단하게 돌면서 인접한 두 수가 정렬이 안 되어 있으면 서로 바꾼다.

```python
def buble_sort(arr):
    arr_len = len(arr)
    for i in range(arr_len - 1):
        for j in range((arr_len - 1) - i):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr
```

배열을 정직하게 n<sup>2</sup> 번 씩 돌면서 정렬한다.

![버블정렬](https://ritualforrain.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fbb0e6649-f417-4ab2-8c2a-a6b2647eee9a%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_11.37.36.png?table=block&id=6ba53bd9-36cd-4cd3-ba40-6ec5efcd7f06&spaceId=3534bf20-7a07-42e1-b6b0-c55e873160bb&width=2000&userId=&cache=v2)

이런 방식으로 가장 오른쪽에서 부터 정렬이 완성되어가는 것을 알 수 있다.



### 병합 정렬

이건 분할 정복을 이용한 정렬 방법으로 메모리를 많이 쓰지만, 안정적으로 정렬하는게 장점인 정렬.

- 정렬 방법
  1. 들어온 배열을 반으로 나눈다.
  2. 재귀를 사용하여 반으로 나눠진 배열을 다시 반으로 나눈다.
  3. 더 이상 나누어지지 않을 때까지 배열을 나눈다.
  4. 위로 거슬러 올라가며 쪼개진 배열들을 정렬한다.

```python
def merge_sort(arr: list) -> list:
    def merge(left: list, right: list) -> list:
        result = []
        l_head = 0
        r_head = 0
        while l_head < len(left) and r_head < len(right):
            if left[l_head] < right[r_head]:
                result.append(left[l_head])
                l_head += 1
            else:
                result.append(right[r_head])
                r_head += 1
        if l_head < len(left):
            result.extend(left[l_head:])
        if r_head < len(right):
            result.extend(right[r_head:])
        return result

    arr_len = len(arr)
    if arr_len <= 1:
        return arr
    mid = arr_len // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    result = merge(left, right)
    return result
```

![병합 정렬](https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif)



### 병합 정렬의 경우의 시간 복잡도.

![스크린샷 2022-05-14 오후 3.57.44.png](https://ritualforrain.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F4d74c291-bf68-4b51-a169-8d82ae6ba158%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-14_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.57.44.png?table=block&id=d3736b71-6730-4e61-babe-a4d95b9535a1&spaceId=3534bf20-7a07-42e1-b6b0-c55e873160bb&width=2000&userId=&cache=v2)

이 경우에는 시간 복잡도가 $n*(log_2  n)$으로 상수항을 제거하면

$n*(log n / log 2) = nlogn$ 으로 시간이 확 줄어들게 됩니다.

즉, 같은 문제를 풀더라도 어떻게 푸느냐에 따라 걸리는 시간이 확확 줄어들기 때문에 중요하다.



