# 제네릭

제네릭이란 여러 타입이 들어가는 동일한 클래스를 구현하고 싶을 때 만드는 방법이다

```kotlin
abstract class Furniture(name: String)

class Chair(name: String, leg: Int) : Furniture(name)

class Desk(name: String, leg: Int) : Furniture(name)

class Box<T> {
    private val itemBox: MutableList<T> = mutableListOf()

    fun put(item: T) {
        this.itemBox.add(item)
    }

    fun pop(): T {
        val answer = this.itemBox.first()
        this.itemBox.removeAt(0)
        return answer
    }
}
```

예를 들면 위의 예시 같은 경우에는

한 종류의 가구를 넣는 상자를 만들고 싶은데, Chiar를 넣는 상자와 Desk를 넣는 상자를 각각 구현하는 대신 제네릭을 사용해서 동일한 기능을 하는 함수를 만드는 방식이다.





## 무공변

무공변에 대해 에러가 발생하는 예시를 하나 들자면

```kotlin
abstract class Furniture(name: String)

class Chair(name: String, leg: Int) : Furniture(name)

class Desk(name: String, leg: Int) : Furniture(name)

class Box<T> {
    private val itemBox: MutableList<T> = mutableListOf()

    fun put(item: T) {
        this.itemBox.add(item)
    }

    fun pop(): T {
        val answer = this.itemBox.first()
        this.itemBox.removeAt(0)
        return answer
    }

    fun moveFurniture(box : Box<T>) {
        this.itemBox.addAll(box.itemBox)
    }
}

fun moveFurniture() {
    val chairBox = Box<Chair>()
    chairBox.put(Chair("책상 의자", 4))

    val furnitureBox = Box<Furniture>()
    furnitureBox.moveFurniture(chairBox)    // 에러 발생
//    Type mismatch.
//    Required:
//        Box<Furniture>
//    Found:
//        Box<Chair>
}
```

이 부분에서 에러가 발생하는 것을 알 수가 있다.

즉, `Box<Funiture>`이 들어가야하는 위치에 `Box<Chair>`가 들어가서 에러가 발생한다는 에러이다.



하지만, Chair은 Funiture의 자식 클래스니까, 정상적으로 작동을 해야하는게 아닐까 하는 의문이 생긴다.



이에 대해 좀 더 설명하자면

`Funiture` -> `Chair` 는 자식 클래스지만,

`Box<Funiture>`  ->  `Box<Chair>` 는 관계가 없는 클래스이다.

즉, Box안의 제네릭들 끼리만 상속 관계일뿐, 그 밖의 Box는 상속 관계가 아닌 아무 관계가 아니라는 뜻이다.



즉, 이것을 무공변이라고 한다.



